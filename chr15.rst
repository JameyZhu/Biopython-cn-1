第 15 章  聚类分析
============================

聚类分析是基于样本两两之间的相似程度将样本分组的操作。在生物信息学中，聚类分析常被用于基因表达数据的分析，从而来寻找有相似基因表达性质的基因类群。这样一来，我们可以找到功能相关的多个基因，同时也可以预测一些未知基因的功能。

Biopython 的 ``Bio.Cluster`` 模块提供了常用的聚类算法，并且已经被预设专门应用于基因表达的数据分析。 但是， 这个模块事实上可以用于其他类型的数据。 有关``Bio.Cluster`` 模块和其中的 C 程序库的描述可以参见 De Hoon *et al.* [`14 <#dehoon2004>`__\ ]。


``Bio.Cluster``模块中可以执行以下四种聚类算法:

-  层次聚类（质心连锁方法，单链方法，全链方法，组平均方法） (pairwise centroid-, single-, complete-, and
   average-linkage);
-  *k*-均值聚类, *k*-中值聚类, and *k*-medoids聚类（无中文名称）;
-  自组织图 Self-Organizing Maps;
-  主成分分析 Principal Component Analysis.

数据表示
~~~~~~~~~~~~~~~~~~~

待聚类的数据用一个 *n* × *m* 的Python 数值向量 ``data`` 表示。在基因表达数据聚类中，通常 行 表示不同的基因种类，而 列 对应着不同的实验条件。 ``Bio.Cluster`` 模块中的聚类算法既可以用于行（基因），也可以用于列（实验条件）。

缺失值
~~~~~~~~~~~~~~

通常在微阵列（基因芯片）实验中，一些数据值是缺失的。缺失数据常常通过一个额外的 *n* × *m* 的Python 整型数值向量 ``mask`` 来指示：
 
假如 ``mask[i,j]==0``, 那么数据 ``data[i,j]`` 就是缺失的，并会在聚类分析中被忽略。 



随机数发生器
~~~~~~~~~~~~~~~~~~~~~~~

 *k*-均值/中值/medoids 聚类算法和自组织图（SOMs）中使用到了一个随机数发生器。 ``Bio.Cluster`` 模块中使用的统一的随机数发生器是基于 L’Ecuyer [`25 <#lecuyer1988>`__\ ]  的算法的, 同时服从二项分布的随机数是使用  Kachitvichyanukul and Schmeiser [`23 <#kachitvichyanukul1988>`__\ ]的 BTPE 算法产生的。 随机数发生器会在第一次调用时自动地初始化。 由于这个随机数发生器使用地是两个乘线性同余方法地组合，所以初始化过程需要两个整型的种子（seeds），同时我们也会用到系统提供的 C 标准库中的 随机数发生器 ``rand`` 。整个过程如下：
 
 我们首先会通过调用   ``srand``（这个过程很耗时，会花掉数秒）来初始化随机数发生器，然后使用  ``rand``产生的前两个随机数作为 ``Bio.Cluster``中随机数发生器的种子。

15.1  距离函数
------------------------

为了能够将样本在他们的基础上聚类成群,我们应该首先定义究竟什么称作是 *相似（similar）*的。 ``Bio.Cluster``模块 给我们提供8种距离函数来衡量相似程度（或者反过来说称之为距离），并分别用单个字母指示：

-  ``'e'``: 欧几里得（Euclidean）距离;
-  ``'b'``: 城市街区距离（也称曼哈顿距离）;
-  ``'c'``: Pearson 相关系数;
-  ``'a'``: Pearson 相关系数的绝对值;
-  ``'u'``:  非中心的（Uncentered） Pearson 相关系数 (相当于两个数据向量的夹角余弦);
-  ``'x'``:  非中心的 Pearson 相关系数的绝对值;
-  ``'s'``: 史匹曼（Spearman）等级相关系数;
-  ``'k'``: 肯德尔（Kendall）的 τ.

上述8种中，前两个是 满足三角不等式的真实的（有物理意义的）距离函数：

*d*

| ⎛
|  ⎜
|  ⎝

+-------+
| *u*   |
+-------+
+-------+

,

+-------+
| *v*   |
+-------+
+-------+

| ⎞
|  ⎟
|  ⎠

≤ \ *d*

| ⎛
|  ⎜
|  ⎝

+-------+
| *u*   |
+-------+
+-------+

,

+-------+
| *w*   |
+-------+
+-------+

| ⎞
|  ⎟
|  ⎠

+ \ *d*

| ⎛
|  ⎜
|  ⎝

+-------+
| *w*   |
+-------+
+-------+

,

+-------+
| *v*   |
+-------+
+-------+

| ⎞
|  ⎟
|  ⎠

对所有的 for all  

+-------+
| *u*   |
+-------+
+-------+

, 

+-------+
| *v*   |
+-------+
+-------+

, 

+-------+
| *w*   |
+-------+
+-------+




，因此他们被称为 *测度（metrics）*. 在任何一种语言文化中，这意味着两点之间，线段最短。

剩下的其他6种距离测量和和相关系数有关。其中距离 *d*被定义为   *d*\ =1−*r*\ ，而*r* 是相关系数。这些距离函数不满足三角不等式，被称为*半测度（semi-metrics）* 。 例如，

对于

+-------+
| *u*   |
+-------+
+-------+

=

| ⎛
|  ⎝

1,0,−1

| ⎞
|  ⎠

;

+-------+
| *v*   |
+-------+
+-------+

=

| ⎛
|  ⎝

1,1,0

| ⎞
|  ⎠

;

+-------+
| *w*   |
+-------+
+-------+

=

| ⎛
|  ⎝

0,1,1

| ⎞
|  ⎠

;

我们找到一个 Pearson 距离 *d*\ (*u*,\ *w*) = 1.8660, while
*d*\ (*u*,\ *v*)+\ *d*\ (*v*,\ *w*) = 1.6340.

欧几里得距离
~~~~~~~~~~~~~~~~~~

在 ``Bio.Cluster``模块中, 我们这样定义距离

*d* = 

+-------+
| 1     |
+-------+
+-------+
| *n*   |
+-------+

 

+-----------+
| *n*       |
+-----------+
| ∑         |
+-----------+
| *i*\ =1   |
+-----------+

 

| ⎛
|  ⎝

*x*\ :sub:`*i*`\ −\ *y*\ :sub:`*i*`

| ⎞
|  ⎠

:sup:`2`.


只有那些 *x*\ :sub:`*i*` 和 *y*\ :sub:`*i*` 同时存在的项才会被包含在求和中，同时 分母 *n*取相应的值。 当表达数据 *x*\ :sub:`*i*` 和 *y*\ :sub:`*i*` 直接互相想减时, 我们应该确保表达数据已经使用欧几里得距离正确地归一化了。

城市街区距离
~~~~~~~~~~~~~~~~~~~

城市街区距离（又称曼哈顿距离）与欧几里得距离有关。但是欧几里得距离对应的是两点之间的最短路径，而城市街区距离是每个维度上距离的总和。由于基因表达数据常常含有缺失值，在  ``Bio.Cluster``模块中，我们把城市街区距离定义成 距离之和 除以 维数：

*d* = 

+-------+
| 1     |
+-------+
+-------+
| *n*   |
+-------+

 

+-----------+
| *n*       |
+-----------+
| ∑         |
+-----------+
| *i*\ =1   |
+-----------+

 

| ⎪
|  ⎪

*x*\ :sub:`*i*`\ −\ *y*\ :sub:`*i*`

| ⎪
|  ⎪

.

这个与我们在城市的两点之间步行时所走过的距离相等，也就是说我们必须沿着街道步行。对于欧几里得距离，表达数据是直接互相相减得到的，我们应该确保他们已经被正确地归一化了。

 Pearson 相关系数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Pearson 相关系数被定义为

*r* = 

+-------+
| 1     |
+-------+
+-------+
| *n*   |
+-------+

 

+-----------+
| *n*       |
+-----------+
| ∑         |
+-----------+
| *i*\ =1   |
+-----------+

 

| ⎛
|  ⎜
|  ⎜
|  ⎝

+----------------------+
| *x*\ :sub:`*i*` −x   |
+----------------------+
+----------------------+
| σ\ :sub:`*x*`        |
+----------------------+

 

| ⎞
|  ⎟
|  ⎟
|  ⎠

| ⎛
|  ⎜
|  ⎜
|  ⎝

+----------------------+
| *y*\ :sub:`*i*` −ȳ   |
+----------------------+
+----------------------+
| σ\ :sub:`*y*`        |
+----------------------+

 

| ⎞
|  ⎟
|  ⎟
|  ⎠

,

其中 x, ȳ 分别是 *x* 和 *y* 的样本平均数, 同时
σ\ :sub:`*x*`和 σ\ :sub:`*y*` 分别是  *x*
和 *y*的样本标准差. Pearson 相关系数可以理解成一条直线对于*x* 和 *y* 二维的散点的拟合程度的度量。如果散点图上的所有点都落在一条直线上，那么 Pearson 相关系数就是 +1 或 -1，取决于斜率是正还是负。如果 Pearson 等于0，那么 *x* 和 *y*之间没有相关性。

 *Pearson 距离* 可以定义为

+----------------------------+
| *d*\ :sub:`P` ≡ 1 − *r*.   |
+----------------------------+

由于 Pearson 相关系数的值介于 -1 和 1之间, Pearson 距离介于 0 和 2之间。

绝对 Pearson 相关
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

通过取the Pearson 相关系数的绝对值 , 我们可以获得一个介于 0 和 1 之间的数。 如果这个绝对值是1，那么所有的点都落在一条直线上。如果绝对值等于0，那么 *x* 和 *y*之间没有相关性。

对应的距离被定义为： 

+------------------------+------+-------+------+-----+
| *d*\ :sub:`A` ≡ 1 −    | ⎪    | *r*   | ⎪    | ,   |
|                        |  ⎪   |       |  ⎪   |     |
+------------------------+------+-------+------+-----+

其中 *r* 是 Pearson 相关系数。当 Pearson 相关系数的绝对值介于 0 和 1之间时, 对应的距离也是介于 0 和 1 的。

在基因表达实验中， 不论两个基因表达的情况是完全相同或者是完全相反，绝对相关系数都等于1。所以绝对相关系数在使用时需要特别小心。

非中心的Pearson相关系数 (夹角余弦)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在一些情况下， 使用*非中心相关系数*要比使用常规的 Pearson 相关系数更好。非中心相关定义为：

*r*\ :sub:`U` = 

+-------+
| 1     |
+-------+
+-------+
| *n*   |
+-------+

 

+-----------+
| *n*       |
+-----------+
| ∑         |
+-----------+
| *i*\ =1   |
+-----------+

 

| ⎛
|  ⎜
|  ⎜
|  ⎝

+-----------------------------+
| *x*\ :sub:`*i*`             |
+-----------------------------+
+-----------------------------+
| σ\ :sub:`*x*`\ :sup:`(0)`   |
+-----------------------------+

 

| ⎞
|  ⎟
|  ⎟
|  ⎠

| ⎛
|  ⎜
|  ⎜
|  ⎝

+-----------------------------+
| *y*\ :sub:`*i*`             |
+-----------------------------+
+-----------------------------+
| σ\ :sub:`*y*`\ :sup:`(0)`   |
+-----------------------------+

 

| ⎞
|  ⎟
|  ⎟
|  ⎠

,

其中

     

σ\ :sub:`*x*`\ :sup:`(0)`

 =

 

√

+-------+
| 1     |
+-------+
+-------+
| *n*   |
+-------+

 

+-----------+
| *n*       |
+-----------+
| ∑         |
+-----------+
| *i*\ =1   |
+-----------+

*x*\ :sub:`*i*`\ :sup:`2`

;  

 

σ\ :sub:`*y*`\ :sup:`(0)`

 =

 

√

+-------+
| 1     |
+-------+
+-------+
| *n*   |
+-------+

 

+-----------+
| *n*       |
+-----------+
| ∑         |
+-----------+
| *i*\ =1   |
+-----------+

*y*\ :sub:`*i*`\ :sup:`2`

.  

 

除了样本平均数 x, ȳ 被设置为0了之外，这个和常规的Pearson相关系数的数学表达是一致的。 如果存在一个 零参考态（zero reference state） 非中心的相关系数可能是正确的。 例如，在以比值的对数形式给出的基因表达数据中，如果比值的对数等于0（也就是绿色和红色的信号强度相同），这就意味着实验操作不影响基因表达。 

非中心相关系数对应的距离的定义为： 

+--------------------------------------+
| *d*\ :sub:`U` ≡ 1 − *r*\ :sub:`U`,   |
+--------------------------------------+

其中 *r*\ :sub:`U` 是非中心相关。因为非中心相关的值介于 -1 和 1 之间，对应的距离介于 0 和 2 之间。 

非中心相关也等于在一个*n*-维空间中的两个数据向量的余弦值，所以也被称为夹角余弦。 

绝对非中心相关
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

相对于常规的Pearson相关系数，我们可以定义一个使用非中心相关的绝对值的距离： 

+-------------------------+------+-----------------+------+-----+
| *d*\ :sub:`AU` ≡ 1 −    | ⎪    | *r*\ :sub:`U`   | ⎪    | ,   |
|                         |  ⎪   |                 |  ⎪   |     |
+-------------------------+------+-----------------+------+-----+

其中 *r*\ :sub:`U` 是非中心的相关系数。当非中心相关系数的绝对值介于 0 和 1 之间时，对应的距离也处在 0 到 1 之间。

从几何学上说，非中心相关系数的绝对值等于两个数据向量的支持线（supporting line）之间的余弦值。 

（例如，不考虑向量方向的夹角）


史匹曼等级相关系数
~~~~~~~~~~~~~~~~~~~~~~~~~

史匹曼等级相关系数是非参量的相似性度量的一个例子，在处理离群点方面，它比Pearson相关系数更加鲁棒（robust）.

为了计算史匹曼等级相关系数，我们将每个数据向量中的数据值替换成它所在的数据向量中的等级（即大小顺序）。接着，我们计算两个两个等级向量而非数据向量的Pearson相关系数。 

我们同样可以定义一个距离度量 

+--------------------------------------+
| *d*\ :sub:`S` ≡ 1 − *r*\ :sub:`S`,   |
+--------------------------------------+

其中 *r*\ :sub:`S` 是史匹曼等级相关系数。

肯德尔的 τ
~~~~~~~~~~~

肯德尔的 τ 是非参量相似性度量的另一个例子。

它和史匹曼等级相关系数相类似，但是计算 τ 只使用相对等级而不使用等级本身。 (请参见 Snedecor
& Cochran [`29 <#snedecor1989>`__\ ]).

同样的我们可以定义一个距离度量 

+--------------------------+
| *d*\ :sub:`K` ≡ 1 − τ.   |
+--------------------------+

因为肯德尔的 τ 总是介于 -1 和 1 之间, 所以对应的距离是介于 0 和 2 之间的。

加权
~~~~~~~~~

对于``Bio.Cluster``模块中的大多数距离函数来说, 是可以使用权重向量的。权重向量包含了数据向量中数据的权重。如果数据 *i* 的权重是 *w*\ :sub:`*i*`，那么这就相当于这个数据出现了 *w*\ :sub:`*i*` 次。权重不需要一定是整数。但是对于史匹曼等级相关系数和肯德尔的 τ, 权重没有一个明确的含义，所以不进行加权。

计算距离矩阵
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

距离矩阵是一个包含了``data``中所有成对数据的距离的方阵，能够通过``Bio.Cluster``模块中的 ``distancematrix`` 函数求得：

.. code:: verbatim

    >>> from Bio.Cluster import distancematrix
    >>> matrix = distancematrix(data)

其中定义一下变量：

-  ``data`` (必需的)
    是含有数据的向量 Array containing the data for the items.
-  ``mask`` (默认值: ``None``)
    指使缺失值的整形向量。如果
   ``mask[i,j]==0``, 那么 ``data[i,j]`` 缺失了。 如果 ``mask==None``,
    那么不存在数据缺失。
-  ``weight`` (默认值: ``None``)
    计算距离时的权重。如果 ``weight==None``, 那么假设权重都相等。
-  ``transpose`` (默认值: ``0``)
    决定我们计算的是成行的数据``data``(``transpose==0``)的距离, 还是成列数据的距离``data``(``transpose==1``)。
-  ``dist`` (默认值: ``'e'``, 欧几里得距离)
    决定使用什么样的距离函数 (参见`15.1 <#sec:distancefunctions>`__).

为了节省内存，距离矩阵作为一个一维向量的列表而存在。每行的列数和行数都相等。因此，第一行是0元素。如下是距离矩阵的一个例子。

.. code:: verbatim

    [array([]),
     array([1.]),
     array([7., 3.]),
     array([4., 2., 6.])]

它对应着如下标准形式的距离矩阵：

| ⎛
|  ⎜
|  ⎜
|  ⎜
|  ⎝

+-----+-----+-----+-------+
| 0   | 1   | 7   | 4     |
+-----+-----+-----+-------+
| 1   | 0   | 3   | 2     |
+-----+-----+-----+-------+
| 7   | 3   | 0   | 6     |
+-----+-----+-----+-------+
| 4   | 2   | 6   | 0     |
+-----+-----+-----+-------+

| ⎞
|  ⎟
|  ⎟
|  ⎟
|  ⎠

.

15.2  簇性质的计算 Calculating cluster properties
------------------------------------

计算簇的质心 Calculating the cluster centroids
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

簇的质心既可以被定义成簇中所有项目（或称样本）每个维度上的均值也可以被定义成所有项目每个维度上的中位数。
``Bio.Cluster``模块中的``clustercentroids``函数可以通过以下两种方式调用。

.. code:: verbatim

    >>> from Bio.Cluster import clustercentroids
    >>> cdata, cmask = clustercentroids(data)

其中，一下变量定义如下：

-  ``data`` (必须的)
    包含样本（被聚类项目）的数据的向量。
-  ``mask`` (默认值: ``None``)
    指示数据是否缺失的整形向量。如果 ``mask[i,j]==0``, 那么 ``data[i,j]`` 就缺失了。 如果 ``mask==None``, 那么不存在缺失值。
-  ``clusterid`` (默认值: ``None``)
    指示每个待聚类项目属于哪个簇的整形向量。如果 ``clusterid`` 是 ``None``, 那么所以项目都被聚到了同一个簇。
-  ``method`` (默认值: ``'a'``)
    指定簇的中心究竟是使用算数平均数(``method=='a'``) 还是使用中位数 (``method=='m'``)。
-  ``transpose`` (默认值: ``0``)
    决定究竟是计算成行数据 ``data`` 的质心(``transpose==0``), 还是成列数据 ``data`` 的质心(``transpose==1``).

 这个函数返回元组（tuple，一种数据结构） ``(cdata, cmask)``。 质心数据被存在2维向量``cdata``中, 同时缺失数据由二维整形向量``cmask``指示。如果 ``transpose`` 是 ``0``，那么上述两个向量的维度是簇的数目（列的数目）。如果``transpose`` 是 ``1``，那么上述两个向量的维度是是簇的数目（行的数目）。 每行 (如果 ``transpose`` 是 ``0``) 或每列
(如果 ``transpose`` 是 ``1``) 包含平均后的数据（对应每个簇的质心）。

计算簇之间的距离
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在两个 *（待聚类）项目*的基础上，我们可以定义两个 *簇* 之间的各种距离。在成对的质心连锁聚类和 *k*-均值聚类中两个簇的算数平均值之间的距离用得比较多。在 *k*-medoids 聚类中, 两个簇的中位数之间的距离用得更多。 在单链聚类中，通常使用两个簇的聚类项目之间的成对最短距离。在全链聚类中，通常使用两个簇的最长成对距离。 在组平均聚类中， 通常使用两个簇中所有成对项目的距离的平均值。

为了计算两个簇的距离，我们可以使用：

.. code:: verbatim

    >>> from Bio.Cluster import clusterdistance
    >>> distance = clusterdistance(data)

其中变量的定义如下：

-  ``data`` (必要的)
    包含项目的数据的向量
-  ``mask`` (默认值: ``None``)
    指示缺失数据的整形向量。 如果 ``mask[i,j]==0``, 那么 ``data[i,j]`` 就是缺失的。如果 ``mask==None``, 那么没有数据缺失。
-  ``weight`` (默认值: ``None``)
    计算距离时的权重。 如果 ``weight==None``, 那么假设权重都相等。
-  ``index1`` (默认值: ``0``)
    是属于第 1 个簇的所有项目的指数的列表。一个只含有聚类项目 *i* 的簇可以表示成列表 ``[i]``,或是一个整型 ``i``。
-  ``index2`` (默认值: ``0``)
    是属于第 2 个簇的所有项目的指数的列表。一个只含有聚类项目 *i* 的簇可以表示成列表 ``[i]``,或是一个整型 ``i``。
-  ``method`` (默认值: ``'a'``)
    指定簇与簇之间的距离如何定义：

   -  ``'a'``: 两个簇质心之间的距离(算数平均数);
   -  ``'m'``: 两个簇质心之间的距离(中位数);
   -  ``'s'``: 两个簇中项目的最短成对距离;
   -  ``'x'``: 两个簇中项目的最长成对距离;
   -  ``'v'``: 两个簇所有项目之间成对距离的均值。

-  ``dist`` (默认值: ``'e'``, 欧几里得距离)
    定义使用哪种距离函数 (参见
   `15.1 <#sec:distancefunctions>`__).
-  ``transpose`` (默认值: ``0``)
    如果``transpose==0``, 则计算成行数据``data``的距离。如果 ``transpose==1``, 则计算成列数据``data``的距离。

15.3  划分算法
-----------------------------

划分算法将待聚类的项目分成了 *k* 个簇，从而使得所有项目到他们簇的中心的距离的和最小。 簇的数目 *k* 是由用户指定的。 ``Bio.Cluster``模块提供3种划分算法:

-  *k*-均值聚类
-  *k*-中位数聚类
-  *k*-medoids 聚类

这些算法不同之处在于如何定义一个簇的中心。在 *k*-均值聚类中, 簇中心是簇中所有项目数据的均值构成的向量。而在 *k*-中位数聚类中，簇中心是簇中所有项目的数据的每一维上的中位数组成的向量。最后，在 *k*-medoids 聚类中，簇中心是一个簇中到簇中所有其他项目的距离之和最小的这个项目。最后这个算法适合于距离矩阵已知，但是具体数据未知的情况。例如，在蛋白质相似性的基础上给它们聚类。

 我们使用 期望-最大化（expectation-maximization (EM)）算法来将待分类的项目分成 *k* 组。在 EM 算法的初始化中，我们随机地将项目分配至不同的簇中去。 为了保证没有空簇的存在，我们在每个簇中使用二项分布，使簇中的项目数是一个或多个。 我们然后对待聚类的项目随机地排列可以分配的簇的编号，来保证每个项目都有相等的可能性被分配到每个簇中去。 从而，每个簇都能被保证含有一个项目。

之后我们进行迭代:

-  计算每个簇的质心，可以定义成 均值、中位数或者是 medoid ;
-  计算每个项目到簇中心的距离;
-  对于每个项目，都要判断这个项目到哪个簇中心的距离是最小的;
-  要么重新分配这个项目到最近的簇中心，要么在没有新的簇标号分配的情况下停止迭代。

为了避免在迭代过程中产生空簇，在 *k*-均值聚类和 *k*-中位数聚类中跟踪每个簇中项目的总数目，同时防止簇中最后一个剩下的项目被重新分配到其他的簇中去。对于 *k*-medoids 聚类来说, 这一步的检查是不需要的， 因为作为簇中心的那个项目对自己的距离是0，因此不会比到其他簇更近了。

由于初始化时每个项目都是随机被分配的，所以通常情况下每次执行 EM 算法，都会得到不同的聚类方案。为了找到最佳的聚类方案， *k*-均值算法会被重复多次，并且每次初始化的结果都不同。每次运行时，每个项目到簇中心的距离的和都会被保存下来，同时距离和最小值对应的聚类方案会以最后的聚类方案被返回。

EM 算法应该被执行多少次取决于有多少项目要被聚类。 估测下来，我们可以考虑最佳的聚类方案有多大的可能性被找到； 同时这个数字会在划分算法在库（library）中被执行的时候返回。如果最佳方案被找到多次，那么很难找到其他更好的方案了。但是，如果最佳的方案只被找到了一次，那么很可能存在着其他更好的方案。如果待分类项目的数目特别大（多于几百个），那么想要找到全局的最佳方案可能很难。

EM 算法会在没有新的簇标号的重新分配发生时终止。实践中，我们可以发现，对于一些初始的簇标号分配， EM 算法在同种聚类方案重复地周期性出现时无法收敛。我们因此会在迭代过程中检查这种周期性方案的出现。在一定数目的迭代之后，当前的聚类结果会被保存成一个参照（reference）。 通过将每步迭代后的结果与参考状态进行比较，我们可以知道有没有遇到之前出现过的聚类结果。在这种情况下，迭代会被暂停。如果在一定数目的迭代后，没有遇到参照态，那么当前状态可以被保存为新的参照状态。最开始，在保存参照态之前会执行10个迭代。这个迭代数目每次会加倍，来保证更长的周期性行为能被检测得到。



*k*-均值 and *k*-中位数
~~~~~~~~~~~~~~~~~~~~~~~~~

*k*-均值 和 *k*-中位数算法在 ``Bio.Cluster`` 模块中通过函数 ``kcluster`` 实现 :

.. code:: verbatim

    >>> from Bio.Cluster import kcluster
    >>> clusterid, error, nfound = kcluster(data)

其中变量定义如下:

-  ``data`` (必需的)
    包含数据的项目的向量。
-  ``nclusters`` (默认值: ``2``)
    簇的数目 *k*.
-  ``mask`` (默认值: ``None``)
    指示数据是否缺失的整形向量。如果 ``mask[i,j]==0``, 那么 ``data[i,j]`` 就缺失了。 如果 ``mask==None``, 那么不存在缺失值。
-  ``weight`` (默认值: ``None``)
    计算距离时的权重。 如果 ``weight==None``, 那么假设权重都相等。
-  ``transpose`` (默认值: ``0``)
    如果``transpose==0``, 则计算成行数据``data``的距离。如果 ``transpose==1``, 则计算成列数据``data``的距离。
-  ``npass`` (默认值: ``1``)
     *k*-均值/-中位数聚类算法执行的次数，每次执行时初始条件不同。如果 ``initialid`` 给定了，那么 ``npass`` 的值会被忽略，同时聚类算法只运行一次。
-  ``method`` (默认值: ``a``)
    描述簇的中心如何定义:

   -  ``method=='a'``: 算数平均数(*k*-均值聚类);
   -  ``method=='m'``: 中位数 (*k*-中位数聚类).

    ``method``如果取其他值, 会默认使用算数平均值.
-  ``dist`` (默认值: ``'e'``, 欧几里得距离)
    决定使用哪个距离函数 (参见
   `15.1 <#sec:distancefunctions>`__)。 虽然 ``kcluster`` 对所有的8种距离函数都能接受, 但是，从理论的角度来看，对 *k*-均值算法最好使用欧几里得距离, 对 *k*-中位数聚类算法，最好使用城市街区距离。
-  ``initialid`` (默认值: ``None``)
     指定对于 EM algorithm使用哪种初始聚类。如果 ``initialid==None``, 那么 ``npass`` 中的每次运行 EM 算法都会有不同随机的初始化的聚类方案. 如果 ``initialid`` 的值不是 ``None``, 那么每个项目会有一个包含簇编号 (介于 ``0`` 到 ``nclusters-1``) 的1维向量。每个簇至少含有一个项目。如果指定了初始的聚类方案，那么 EM 算法的执行是确定了的。

这个函数会返回一个元组（tuple） ``(clusterid, error, nfound)``, 其中
``clusterid`` 是一个包含了每个行或簇被分配到的簇的编号的整型向量， ``error`` 是最佳聚类方案中簇内距离的和，  ``nfound`` 是最佳聚类方案找到的次数。


*k*-medoids 聚类
~~~~~~~~~~~~~~~~~~~~~~

 ``kmedoids`` 方法在一组给定的项目上、使用距离矩阵和用户指定的簇的个数执行 *k*-medoids 聚类：

.. code:: verbatim

    >>> from Bio.Cluster import kmedoids
    >>> clusterid, error, nfound = kmedoids(distance)

其中变量定义如下： , nclusters=2, npass=1,
initialid=None)\|

-  ``distance`` (必要的)

    包含项目之间距离的矩阵；这个矩阵可以通过3种途径指定：

   -  作为2维向量（其中只有向量左边更小的部分能被读取到）： as a 2D Numerical Python array (in which only the left-lower part of the array will be accessed):

      .. code:: verbatim

          distance = array([[0.0, 1.1, 2.3],
                            [1.1, 0.0, 4.5],
                            [2.3, 4.5, 0.0]])

   -  作为1维向量，包含了距离矩阵的左下部分：    as a 1D Numerical Python array containing consecutively the distances in the left-lower part of the distance matrix:

      .. code:: verbatim

          distance = array([1.1, 2.3, 4.5])

   -  作为包含距离矩阵左下部分的行的列表：

      .. code:: verbatim

          distance = [array([]|,
                      array([1.1]),
                      array([2.3, 4.5])
                     ]

   这些表达形式都对应着相同的距离矩阵。
-  ``nclusters`` (默认值: ``2``)
    簇的个数 *k*.

-  ``npass`` (默认值: ``1``)
     *k*-均值/-中位数聚类算法执行的次数，每次执行时初始条件不同。如果 ``initialid`` 给定了，那么 ``npass`` 的值会被忽略，同时聚类算法只运行一次。

-  ``initialid`` (默认值: ``None``)
     指定对于 EM algorithm使用哪种初始聚类。如果 ``initialid==None``, 那么 ``npass`` 中的每次运行 EM 算法都会有不同随机的初始化的聚类方案. 如果 ``initialid`` 的值不是 ``None``, 那么每个项目会有一个包含簇编号 (介于 ``0`` 到 ``nclusters-1``) 的1维向量。每个簇至少含有一个项目。如果指定了初始的聚类方案，那么 EM 算法的执行是确定了的。

这个函数会返回一个元组 ``(clusterid, error, nfound)``, 其中
``clusterid`` 是一个包含了每个行或簇被分配到的簇的编号的整型向量， ``error`` 是最佳聚类方案中簇内距离的和，  ``nfound`` 是最佳聚类方案找到的次数。 需要注意的是，  ``clusterid``中的簇的编号被定义为代表簇中心的项目的项目编号。

15.4  层次聚类
-----------------------------

层次聚类方法与 *k*-均值聚类方法不同。在层次聚类中，基因表达特征或实验条件的相似性通过树状结构来体现。这种树形结构可以通过 Treeview 和 Java Treeview 这些常用的用于基因表达层次聚类分析工具查看。

层次聚类的第一步是计算距离矩阵，指定所有需要聚类的项目之间的距离。接着，我们通过将两个最靠近的项目连接起来构造一个节点（node）。 接着同样地在最短距离的基础上，连接项目或节点，直到所有项目都属于同一个节点。至此，一个树形结构就能产生了。与 EM algorithm 不同的是，EM 算法使用的是 *k*-聚类, 层次距离的全过程是确定性的（即每个项目不能重新分配到任何其他的簇）。

层次聚类有很多的版本，这些版本在定义子节点之间距离上有所不同。在 ``Bio.Cluster`` 模块中,单链、全链、组平均和质心连锁聚类都是可以使用的。

-  在单链聚类中，两个节点之间的距离定义为两个节点的所有成员中最小的成对距离。
-  在全链聚类中，两个节点之间的距离定义为两个节点的所有成员中最大的成对距离。
-  在组平均聚类中，两个节点之间的距离定义为两个节点的所有成员的所有成对距离的平均值。
-  在成对的质心连锁聚类中，两个节点之间的距离被定义为他们质心之间的距离。簇的质心是将   所有项目取平均值得到的。由于每一步聚类都需要计算新形成的节点和已知节点和项目的距离，所以成对的质心连锁聚类需要的时间比其他聚类方法都要多。另一个特殊之处在于（对于一个基于Pearson相关系数的距离度量），这些距离未必会随着聚类树的增长而增加，甚至可能会减小。             这可能是由于使用Pearson相关系数质心计算与距离计算的不一致导致的：其中，Pearson 相关系数可以对距离计算进行有效地归一化，而在质心计算时则不进行归一化。

对于单链、全链和组平均聚类，两个节点之间的距离可以直接从两个项目之间的距离找到。因此，聚类算法不需要读取原始的基因表达数据，而只需要知道距离矩阵。但是对于成对的质心连锁	聚类，新生成的子节点的质心需要从原始数据中计算获得，而不是从距离矩阵中获得。

成对的单链层次聚类是基于 SLINK 算法 (R. Sibson, 1973)的, 它比直接运行成对的单链聚类更快、内存利用更高效。 这个算法的聚类结果与传统单链算法的聚类结果一致。 在此库中的单链层次聚类算法可以用于对大型的基因表达数据集进行聚类，而传统的层次聚类算法由于过高的内存需求和太长的运行时间无法做到这一点。

层次聚类方案的展示
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

层次聚类的结果由一个有节点的树构成，其中每个节点连接了两个项目或者子节点。通常来说，我们不仅关心项目或子节点是如何连接在每个节点的，同时我们还很关心他们之间的相似度（或距离）。为了存储层次聚类中的一个节点，我们会用到 ``Bio.Cluster``模块中的``Node``类。  ``Node`` 的一个例子含有三个属性：

-  ``left``
-  ``right``
-  ``distance``

这里, ``left`` 和 ``right`` 表示连接到这个节点的两个项目或子节点的整数,同时``distance`` 是两者之间的距离。待聚类的项目的编号范围是 0 到 (项目总数 − 1), 同时簇的编号范围是 -1 到 −(项目总数−1)。需要注意的是，节点的数目要比项目的数目少1.

如果要创建一个新的 ``Node`` 对象, 我们需要指定 ``left`` 和 ``right``; ``distance`` 可以不指定。

.. code:: verbatim

    >>> from Bio.Cluster import Node
    >>> Node(2,3)
    (2, 3): 0
    >>> Node(2,3,0.91)
    (2, 3): 0.91

属性 ``left``, ``right``, 和 ``distance`` 在已经存在的 ``Node`` 对象中可以直接修改：

.. code:: verbatim

    >>> node = Node(4,5)
    >>> node.left = 6
    >>> node.right = 2
    >>> node.distance = 0.73
    >>> node
    (6, 2): 0.73

如果 ``left`` 和 ``right`` 不是整型或者``distance``不能转换成浮点型数值则会出错。


 ``Tree`` 类展示了一个完整的层次聚类方案。 一个 ``Tree`` 对象可以从 ``Node``
的列表中创建:

.. code:: verbatim

    >>> from Bio.Cluster import Node, Tree
    >>> nodes = [Node(1,2,0.2), Node(0,3,0.5), Node(-2,4,0.6), Node(-1,-3,0.9)]
    >>> tree = Tree(nodes)
    >>> print tree
    (1, 2): 0.2
    (0, 3): 0.5
    (-2, 4): 0.6
    (-1, -3): 0.9

 ``Tree`` 的初始化程序会检查这一列节点是否是有效地层次聚类的结果：

.. code:: verbatim

    >>> nodes = [Node(1,2,0.2), Node(0,2,0.5)]
    >>> Tree(nodes)
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    ValueError: Inconsistent tree

 ``Tree`` 对象中单个的节点可以用方括号进行读取：

.. code:: verbatim

    >>> nodes = [Node(1,2,0.2), Node(0,-1,0.5)]
    >>> tree = Tree(nodes)
    >>> tree[0]
    (1, 2): 0.2
    >>> tree[1]
    (0, -1): 0.5
    >>> tree[-1]
    (0, -1): 0.5

由于 ``Tree`` 对象时只读的，我们不能对``Tree`` 对象中的单个节点进行修改。但是，我们可以把树转换成节点的列表，修改这个列表，然后从这个列表里面创建一个新树：

.. code:: verbatim

    >>> tree = Tree([Node(1,2,0.1), Node(0,-1,0.5), Node(-2,3,0.9)])
    >>> print tree
    (1, 2): 0.1
    (0, -1): 0.5
    (-2, 3): 0.9
    >>> nodes = tree[:]
    >>> nodes[0] = Node(0,1,0.2)
    >>> nodes[1].left = 2
    >>> tree = Tree(nodes)
    >>> print tree
    (0, 1): 0.2
    (2, -1): 0.5
    (-2, 3): 0.9

这样就保证了我们创建的任何的 ``Tree`` 对象都是结构上正确的。

如果需要用额外的可视化软件如 Java Treeview 等显示我们创建的层次聚类的结果里面的树，最好对所有的节点距离进行一个比例调整，使得所有的距离都在 0 到 1 之间。 这个可以通过调用 ``scale`` 方法对已经存在的 ``Tree`` 对象进行操作:

.. code:: verbatim

    >>> tree.scale()

这个方法不需要任何变量，返回 ``None``.

层次聚类过后，通过对树进行剪枝，项目会被分成 *k* 个簇：
cutting the tree:

.. code:: verbatim

    >>> clusterid = tree.cut(nclusters=1)

其中 ``nclusters`` (默认为 ``1``) 是簇的个数 *k* 的默认值。 这个方法忽略了顶部的 *k*\ −1个连接行为，产生了 *k* 个分离的项目的簇。簇的个数 *k* 应该是正的，同时不大于项目的个数。这个方法返回一个向量 ``clusterid`` ，它包含着每个项目被分配到哪个簇的编号。

进行层次聚类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

使用``Bio.Cluster`` 模块中的 ``treecluster``函数可以进行层次聚类.

.. code:: verbatim

    >>> from Bio.Cluster import treecluster
    >>> tree = treecluster(data)

其中变量定义如下：

-  ``data``
    包含了数据的项目的向量。
-  ``mask`` (默认值: ``None``)
    指示数据是否缺失的整形向量。如果 ``mask[i,j]==0``, 那么 ``data[i,j]`` 就缺失了。 如果 ``mask==None``, 那么不存在缺失值。
-  ``weight`` (默认值: ``None``)
    计算距离时的权重。 如果 ``weight==None``, 那么假设权重都相等。
-  ``transpose`` (默认值: ``0``)
    如果``transpose==0``, 则计算成行数据``data``的距离。如果 ``transpose==1``, 则计算成列数据``data``的距离。
-  ``method`` (默认值: ``'m'``)
    定义使用什么样的连锁方法:

   -  ``method=='s'``: 成对单链聚类
   -  ``method=='m'``: 成对全链聚类  
   -  ``method=='c'``: 成对质心连锁聚类
   -  ``method=='a'``: 成对组平均聚类

-  ``dist`` (默认值: ``'e'``, 欧几里得距离)
    定义使用哪种距离函数 (参见
   `15.1 <#sec:distancefunctions>`__).

在对事先计算好的距离矩阵进行层次聚类时，在调用 ``treecluster``函数时要指定  ``distancematrix`` 变量而非 ``data`` 变量：

.. code:: verbatim

    >>> from Bio.Cluster import treecluster
    >>> tree = treecluster(distancematrix=distance)
 
在这种情况下，变量定义如下:

-  ``distancematrix``
   距离矩阵，可以通过3种方式指定:

   -  作为一个2维向量 (其中只有左下部分才能被读取到 in which only the left-lower part of the array will be accessed):

      .. code:: verbatim

          distance = array([[0.0, 1.1, 2.3], 
                            [1.1, 0.0, 4.5],
                            [2.3, 4.5, 0.0]])

   -  作为1维向量，包含着距离矩阵的左下部分：

      .. code:: verbatim

          distance = array([1.1, 2.3, 4.5])

   -  作为距离矩阵的左下部分的行的列表:

      .. code:: verbatim

          distance = [array([]),
                      array([1.1]),
                      array([2.3, 4.5])

   这3种表现形式对应的是同一个距离矩阵。由于 ``treecluster`` 会打乱距离矩阵中的值，所以在调用 ``treecluster`` 之前应该把这个向量保存在一个不同的变量中去。

-  ``method``
    所使用的连锁方法:

   -  ``method=='s'``: 成对的单链聚类
   -  ``method=='m'``: 成对的全链聚类
   -  ``method=='a'``: 成对的组平均聚类

   虽然单链、全链和组平均聚类能在距离矩阵上进行计算，而成对的质心连锁聚类不行。 

当调用 ``treecluster``的时候,  ``data`` 或者 ``distancematrix``变量应该取 ``None``.

这个函数会返回一个 ``Tree`` 对象。这个对象包含了(项目数 − 1) 个节点，如果聚类的对象是行，那么项目个数和行数相等。如果聚类的对象是列，那么项目的个数和列数相等。每个节点描述了一个成对的连接行为，其中节点的属性 ``left`` 和 ``right`` 包含了项目或者子节点的编号，同时 ``distance`` 是两者的距离。项目的编号是从 0 到 (项目总数 − 1), 同时簇的编号是从 -1 到 −( 项目总数 − 1).

15.5  自组织图
--------------------------

自组织图 (SOMs) 由 Kohonen 发明，主要用于描述神经网络 (参见 for instance Kohonen, 1997 [`24 <#kohonen1997>`__\ ]).
Tamayo (1999) 第一次将自组织图用到基因表达数据上。
[`30 <#tamayo1999>`__\ ].

SOMs 将项目组织成位于拓扑结构中的一些簇。通常会选择一个矩形的拓扑结构。SOMs 产生的簇与邻近的簇在拓扑上比较远的簇更相似。

计算 SOM 的第一步是为拓扑中的每一个簇随机分配一个数据向量。如果被聚类的对象是行，那么每个数据向量中的元素数量等于列的数目。

SOM 通过一次选取一行产生，然后在拓扑中寻找到哪个数据向量最接近。
这个簇的数据向量和邻近簇的数据向量，都会借助行的数据向量进行调整。这个调整由以下给予

Δ 

+-------+
| *x*   |
+-------+
+-------+

:sub:`cell` = τ · 

| ⎛
|  ⎜
|  ⎝

+-------+
| *x*   |
+-------+
+-------+

:sub:`row` − 

+-------+
| *x*   |
+-------+
+-------+

:sub:`cell` 

| ⎞
|  ⎟
|  ⎠

.
参数 τ 是一个每次迭代都会减少的一个参数。 我们使用的是每次迭代的简单线性函数：

τ = τ\ :sub:`init` · 

| ⎛
|  ⎜
|  ⎜
|  ⎝

1 − 

+--------+
| *i*    |
+--------+
+--------+
| *n*    |
+--------+

| ⎞
|  ⎟
|  ⎟
|  ⎠

,

τ\ :sub:`init` 是用户指定的 τ 的初始值, *i* 是当前迭代步骤的编号， *n* 是需要进行迭代的总数。 在迭代的初期，变化很大；在末期，变化很小。

在半径 *R* 内的所有簇会根据所研究的基因进行调整。这个半径会随着计算过程而减小，因为

*R* = *R*\ :sub:`max` · 

| ⎛
|  ⎜
|  ⎜
|  ⎝

1 − 

+--------+
| *i*    |
+--------+
+--------+
| *n*    |
+--------+

| ⎞
|  ⎟
|  ⎟
|  ⎠

,

其中，最大的半径定义为

*R*\ :sub:`max` = 

√

+---------------------------------------------------------+
+---------------------------------------------------------+
| *N*\ :sub:`*x*`\ :sup:`2` + *N*\ :sub:`*y*`\ :sup:`2`   |
+---------------------------------------------------------+

,

其中 (*N*\ :sub:`*x*`, *N*\ :sub:`*y*`) 是定义拓扑的矩形的维数。

 ``somcluster`` 函数会在一个矩形网格上计算自组织图。一开始，它会初始化随机数发生器。节点数据通过随机数发生器进行初始化。用于修改  SOM 的基因或者微阵列的顺序也会被随机化处理。 SOM 算法中的迭代总数由用户指定。

为了运行 ``somcluster``, 使用

.. code:: verbatim

    >>> from Bio.Cluster import somcluster
    >>> clusterid, celldata = somcluster(data)

其中变量定义如下：

-  ``data`` (必需的)
    包含了数据的项目的向量。
-  ``mask`` (默认值: ``None``)
    指示数据是否缺失的整形向量。如果 ``mask[i,j]==0``, 那么 ``data[i,j]`` 就缺失了。 如果 ``mask==None``, 那么不存在缺失值。
-  ``weight`` (默认值: ``None``)
    计算距离时的权重。 如果 ``weight==None``, 那么假设权重都相等。
-  ``transpose`` (默认值: ``0``)
    如果``transpose==0``, 则计算成行数据``data``的距离。如果 ``transpose==1``, 则计算成列数据``data``的距离。
-  ``nxgrid, nygrid`` (默认值: ``2, 1``)
    在矩形网格中横向和纵向上计算自组织图的小格的数目。
-  ``inittau`` (默认值: ``0.02``)
    SOM 算法中用到的 τ 的初始值。``inittau`` 的默认值是 0.02, 同时也在 Michael Eisen 的 Cluster/TreeView 程序中使用。
-  ``niter`` (默认值: ``1``)
    迭代总次数。
-  ``dist`` (默认值: ``'e'``, 欧几里得距离)
    定义使用距离函数 (参见
   `15.1 <#sec:distancefunctions>`__).

 这个函数返回元组 ``(clusterid, celldata)``:

-  ``clusterid``:
    是一个有两列的向量，其中行数等于被聚类的项目数。每一行都包含着在 SOM 矩形网格上小格子的 *x* 和 *y* 坐标。

-  ``celldata``:
    如果行被聚类，则它是一个维数是 (``nxgrid``, ``nygrid``, 列数) 的向量。如果列被聚类，则它是一个维数是(``nxgrid``, ``nygrid``, 行数)的向量。这个向量中的每个元素 ``[ix][iy]`` 都是一维向量，包含着网格中簇的质心的基因表达数据，同时坐标是 ``[ix][iy]``。

15.6  主成分分析
----------------------------------

主成分分析 (PCA) 是常用于分析多变量数据的技术。将主成分分析用于基因表达数据上的例子是 Yeung 和 Ruzzo (2001) 的[`33 <#yeung2001>`__\ ].

本质上， PCA是一种坐标变换，其中数据矩阵中的每一行被写成的基向量（也就是主成分）的线性组合，从而每个主成分最大程度地得以解释数据向量中的剩余变化。比如，一个 *n* × 3 的数据矩阵可以被表示为三维空间中 *n* 个点构成的椭圆体形状的云。第一个主成分就是这个椭圆体的长轴，第二个主成分就是这个椭圆体的次长轴，第三个主成分就是这个椭圆体的短轴。数据矩阵中的每一行都能被重写成主成分的线性组合。但是为了给数据降维，通常只有最重要的主成分被保留了。数据中余下的变异被认为是非期望的变异。

主成分可以通过计算数据的协方差矩阵的特征值得到。对应的特征值决定了数据中存在的多少变异可以通过对应的主成分来解释。

在使用主成分分析之前，数据矩阵的中的每一列的均值都会被提取出来。在上面的例子中，在三维的空间中，这个椭球形状的云的中心在其质心，同时，其主成分描述了云中的点相对于他们质心的变异。

以下介绍的函数 ``pca`` 首先使用了奇异值分解来计算数据矩阵的特征值和特征向量。奇异值分解是通过 Algol 的  ``svd`` 进行的[`16 <#golub1971>`__\ ], 它使用了 Householder 的双对角化和 QR 算法的一个变种。 主成分、主成分对应的数据向量的坐标和主成分对应的特征值会被求值、并按照特征值降序的顺序返回。如果需要数据的中心化，在调用 ``pca`` 之前数据矩阵的每一列都需要减去一个平均数。

在一个矩形数据矩阵 ``data`` 上使用主成分分析,使用

.. code:: verbatim

    >>> from Bio.Cluster import pca
    >>> columnmean, coordinates, components, eigenvalues = pca(data)

这个函数返回一个元组
``columnmean, coordinates, components, eigenvalues``:

-  ``columnmean``
     ``data``中每列均值构成的向量。
-  ``coordinates``
    ``data`` 中与主成分对应的每行中的坐标。
-  ``components``
    主成分。
-  ``eigenvalues``
    主成分对应的特征值。

最初的数据矩阵 ``data`` 可以通过计算 ``columnmean +  dot(coordinates, components)`` 来重新构建。

15.7  处理 Cluster/TreeView 类型的文件
------------------------------------------

Cluster/TreeView 是基于用户图形界面（GUI）的用于给基因表达数据聚类的代码。 它们最初是由 `Michael
Eisen <http://rana.lbl.gov>`__ 在斯坦福大学时写的。
``Bio.Cluster`` 模块包含了读写 Cluster/TreeView 对应格式文件的功能。尤其是把聚类结果存成 TreeView 可以读取并进行可视化的格式。我们尤其推荐 Alok
Saldanha’s 的
```http://jtreeview.sourceforge.net/`` <http://jtreeview.sourceforge.net/>`__\ Java
TreeView 程序, 它不仅能够显示层次聚类的结果，也能显示 *k*-均值聚类的结果。

``Record`` 类包含了储存在 Cluster/TreeView 类型文件中的所有数据。为了存储 ``Record`` 对象中数据文件的信息，我们首先打开文件，然后读取：

.. code:: verbatim
	
	>>> from Bio import Cluster
    >>> handle = open("mydatafile.txt")
    >>> record = Cluster.read(handle)
    >>> handle.close()

这种两步处理的方式在数据来源方面给予了我们灵活性。比如，我们可以使用

.. code:: verbatim

    >>> import gzip # Python standard library
    >>> handle = gzip.open("mydatafile.txt.gz")

来打开一个 gzip 文件, 或者

.. code:: verbatim

    >>> import urllib # Python standard library
    >>> handle = urllib.urlopen("http://somewhere.org/mydatafile.txt")
 
在调用 ``read`` 之前打开一个 Internet 的文件。

 ``read`` 命令可以读取制表符隔开的文本文件 ``mydatafile.txt``，这个文本文件包含了 Cluster/TreeView 程序指定的基因表达的数据。Cluster/TreeView 的手册中有这个文件格式的描述。可以参见 Michael Eisen 实验室网站  <http://rana.lbl.gov/manuals/ClusterTreeView.pdf>`__ and at `或是我们的网站
 <http://bonsai.ims.u-tokyo.ac.jp/~mdehoon/software/cluster/cluster3.pdf>`__.

一个 ``Record`` 对象有以下属性:

-  ``data``
    包含基因表达数据的数据向量。基因是成行储存的，微阵列是成列储存的。
-  ``mask``
    这个向量指定了 ``data`` 中哪些数据是缺失的。如果 ``mask[i,j]==0``, 那么 ``data[i,j]`` 是缺失的。如果没有数据缺失， ``mask`` 被设置为 ``None``.
-  ``geneid``
    这是一个包含基因特征描述的列表，例如包含了 ORF 的数目。
-  ``genename``
    这是一个包含基因特征描述的列表，例如包含了基因名称。如果在数据文件中没有这个属性，那么 ``genename`` 被设置为 ``None``。
-  ``gweight``
    是用于计算基因表达数据之间计算距离的权重。如果数据文件中没有，则 ``gweight`` 被设定为 ``None``.
-  ``gorder``
    在输出文件中基因应该被存储的顺序。如果数据文件中不存在,那么 ``gorder`` 被设定为 ``None``.
-  ``expid``
    包含每个微阵列描述的列表，例如，实验条件。
-  ``eweight``
    是用于计算微阵列之间距离的权重。如果数据文件中不存在，那么 ``eweight`` 被设定为 ``None``.
-  ``eorder``
    输出文件中微阵列应该被存储的顺序。如果数据文件中没有，那么 ``eorder`` 被设定为   ``None``.
-  ``uniqid``
    在数据文件中取代 UNIQID 的字符串。

在载入了一个 ``Record`` 对象之后, 每个属性都能被直接访问和修改。例如，数据能通过在 ``record.data`` 上使用算法被对数变换。

计算距离矩阵
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了计算在记录中存储的项目之间的距离矩阵，使用


.. code:: verbatim

    >>> matrix = record.distancematrix()

其中变量定义如下:

-  ``transpose`` (默认值: ``0``)
    决定是计算 ``data`` 行与行之间的距离 (``transpose==0``), 还是计算 ``data``
    列与列之间的距离 (``transpose==1``).
-  ``dist`` (默认值: ``'e'``, 欧几里得距离)
    定义使用哪种距离函数(参见
   `15.1 <#sec:distancefunctions>`__).

这个函数返回一个以行的列表存在的距离矩阵，其中每行的列数等于行数 (参见
`15.1 <#subsec:distancematrix>`__).

计算簇质心
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了计算存储在记录中的项目构成的簇的质心，使用

.. code:: verbatim

    >>> cdata, cmask = record.clustercentroids()

-  ``clusterid`` (默认值: ``None``)
    指示每个待聚类项目属于哪个簇的整形向量。如果 ``clusterid`` 是 ``None``, 那么所以项目都被聚到了同一个簇。
-  ``method`` (默认值: ``'a'``)
    描述簇的中心如何定义:

   -  ``method=='a'``: 算数平均数(*k*-均值聚类);
   -  ``method=='m'``: 中位数 (*k*-中位数聚类).

    ``method``如果取其他值, 会默认使用算数平均值.
-  ``transpose`` (默认值: ``0``)
    决定是计算 ``data`` 行与行之间的距离 (``transpose==0``), 还是计算 ``data``
    列与列之间的距离 (``transpose==1``).

这个函数返回一个元组 ``cdata, cmask``; 参见
`15.2 <#subsec:clustercentroids>`__ 中有具体描述。

计算簇与簇之间的距离
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了计算记录中簇之间的距离，使用

.. code:: verbatim

    >>> distance = record.clusterdistance()

其中变量定义如下：

-  ``index1`` (默认值: ``0``)
    是属于第 1 个簇的所有项目的指数的列表。一个只含有聚类项目 *i* 的簇可以表示成列表 ``[i]``,或是一个整型 ``i``。
-  ``index2`` (默认值: ``0``)
    是属于第 2 个簇的所有项目的指数的列表。一个只含有聚类项目 *i* 的簇可以表示成列表 ``[i]``,或是一个整型 ``i``。
-  ``method`` (默认值: ``'a'``)
    指定簇与簇之间的距离如何定义：

   -  ``'a'``: 两个簇质心之间的距离(算数平均数);
   -  ``'m'``: 两个簇质心之间的距离(中位数);
   -  ``'s'``: 两个簇中项目的最短成对距离;
   -  ``'x'``: 两个簇中项目的最长成对距离;
   -  ``'v'``: 两个簇所有项目之间成对距离的均值。

-  ``dist`` (默认值: ``'e'``, 欧几里得距离)
    定义使用哪种距离函数 (参见
   `15.1 <#sec:distancefunctions>`__).
-  ``transpose`` (默认值: ``0``)
    决定是计算 ``data`` 行与行之间的距离 (``transpose==0``), 还是计算 ``data``
    列与列之间的距离 (``transpose==1``).


进行层次聚类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了对存储在记录的项目进行层次聚类，使用

.. code:: verbatim

    >>> tree = record.treecluster()

其中变量定义如下：

-  ``transpose`` (默认值: ``0``)
    决定是计算 ``data`` 行与行之间的距离 (``transpose==0``), 还是计算 ``data``
    列与列之间的距离 (``transpose==1``).

-  ``method`` (默认值: ``'m'``)
    定义使用什么样的连锁方法:

   -  ``method=='s'``: 成对单链聚类
   -  ``method=='m'``: 成对全链聚类  
   -  ``method=='c'``: 成对质心连锁聚类
   -  ``method=='a'``: 成对组平均聚类

-  ``dist`` (默认值: ``'e'``, 欧几里得距离)
     定义使用哪种距离函数 (参见
   `15.1 <#sec:distancefunctions>`__).
-  ``transpose``
    决定究竟是对基因还是微阵列进行聚类。如果 ``transpose==0``,那么基因（行）将被聚类。如果 ``transpose==1``, 微阵列 (列) 将进行聚类。

这个函数会返回一个 ``Tree`` 对象。这个对象包含了 (项目数 − 1) 个节点。 如果行被聚类，那么项目个数等于行数；如果列被聚类，那么项目个数等于列数。每个节点描述了一个成对的连接事件，其中节点属性 ``left`` 和 ``right`` 都包含了项目或者子节点的编号，    ``distance`` 是两者之间的距离。项目编号从 0 到 (项目总数 − 1), 同时簇的个数 编号从 -1 到 −(项目个数−1)。

进行 *k*-均值 或 *k*-中位数聚类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

对记录中的项目执行 *k*-均值 或者 *k*-中位数聚类 ，使用

.. code:: verbatim

    >>> clusterid, error, nfound = record.kcluster()

其中变量定义如下:

-  ``nclusters`` (默认值: ``2``)
    簇的个数 *k*.
-  ``transpose`` (默认值: ``0``)
    决定究竟是对基因还是微阵列进行聚类。如果 ``transpose==0``,那么基因（行）将被聚类。如果 ``transpose==1``, 微阵列 (列) 将进行聚类。
-  ``npass`` (默认值: ``1``)
   *k*-均值/-中位数聚类算法执行的次数，每次执行时初始条件不同。如果 ``initialid`` 给定了，那么 ``npass`` 的值会被忽略，同时聚类算法只运行一次。

-  ``method`` (default: ``a``)
   描述簇的中心如何定义:

   -  ``method=='a'``: 算数平均数(*k*-均值聚类);
   -  ``method=='m'``: 中位数 (*k*-中位数聚类).
   
   对于 ``method`` 的其他值, 将会使用算数平均数。
-  ``dist`` (默认值: ``'e'``, 欧几里得聚类)
    定义使用哪个聚类函数 (参见
   `15.1 <#sec:distancefunctions>`__).

这个函数返回一个元组 ``(clusterid, error, nfound)``, 其中
``clusterid`` 是一个包含了每个行或簇被分配到的簇的编号的整型向量， ``error`` 是最佳聚类方案中簇内距离的和，  ``nfound`` 是最佳聚类方案找到的次数。 需要注意的是，  ``clusterid``中的簇的编号被定义为代表簇中心的项目的项目编号。


计算一个自组织图
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了计算存储在记录中项目的自组织图，使用

.. code:: verbatim

    >>> clusterid, celldata = record.somcluster()

其中，变量定义如下:

-  ``transpose`` (默认值: ``0``)
   决定究竟是对基因还是微阵列进行聚类。如果 ``transpose==0``,那么基因（行）将被聚类。如果 ``transpose==1``, 微阵列 (列) 将进行聚类。
-  ``nxgrid, nygrid`` (默认值: ``2, 1``)
    在矩形网格中横向和纵向上计算自组织图的小格的数目。
-  ``inittau`` (默认值: ``0.02``)
    SOM 算法中用到的 τ 的初始值。``inittau`` 的默认值是 0.02, 同时也在 Michael Eisen 的 Cluster/TreeView 程序中使用。
-  ``niter`` (默认值: ``1``)
    迭代总次数。
-  ``dist`` (默认值: ``'e'``, 欧几里得聚类)
    决定使用哪种距离函数(参见
   `15.1 <#sec:distancefunctions>`__).

这个函数返回元组 ``(clusterid, celldata)``:

-  ``clusterid``:
    是一个有两列的向量，其中行数等于被聚类的项目数。每一行都包含着在 SOM 矩形网格上小格子的 *x* 和 *y* 坐标。

-  ``celldata``:
    如果行被聚类，则它是一个维数是 (``nxgrid``, ``nygrid``, 列数) 的向量。如果列被聚类，则它是一个维数是(``nxgrid``, ``nygrid``, 行数)的向量。这个向量中的每个元素 ``[ix][iy]`` 都是一维向量，包含着网格中簇的质心的基因表达数据，同时坐标是 ``[ix][iy]``。

保存聚类结果
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了保存聚类结果，使用

.. code:: verbatim

    >>> record.save(jobname, geneclusters, expclusters)

其中变量定义如下:

-  ``jobname``
     ``jobname`` 字符串是那些需要保存的文件的前缀名称。
-  ``geneclusters``
    这个变量描述了基因（成行）的聚类结果。在 *k*-均值聚类中，这是一个一维向量，包含着每个基因属于哪个簇的信息。它可以用 ``kcluster`` 进行计算。在层次聚类中，``geneclusters`` 是一个 ``Tree`` 对象。
-  ``expclusters``
    这个变量描述的是实验条件的成列的聚类结果。在 *k*-均值聚类中,这是一个一维向量，包含了每个实验条件属于哪个簇的簇的编号。它可以使用  ``kcluster`` 进行计算。 在层次聚类中，  ``expclusters`` 是一个 ``Tree`` 对象。

这个方法会写入文本文件 ``jobname.cdt``, ``jobname.gtr``,
``jobname.atr``, ``jobname*.kgg``, 和/或 ``jobname*.kag`` 来让后续的 Java TreeView 程序读取。如果 ``geneclusters`` 和 ``expclusters`` 都是 ``None``, 那么这个方法只会写出文件 ``jobname.cdt``; 这个文件后续可以被读入一个新的 ``Record`` 对象。

15.8  计算实例
-------------------------

这是一个对基因进行单链聚类，对实验条件进行全链聚类的层次聚类的例子。因为基因聚类要用到欧几里得距离，需要对节点距离 ``genetree`` 进行归一化使它的值在 0 到 1 之间。这一点对于 Java TreeView 程序来正确显示这个树形图来说是非常重要的。为了对实验数据进行聚类，我们可以使用非中心化的相关系数。这个例子不需要归一化，因为 ``exptree``
中的距离已经是介于 0 和 2 之间的了。案例数据 ``cyano.txt`` 可以在 ``data`` 的子目录找到。

.. code:: verbatim

    >>> from Bio import Cluster
    >>> handle = open("cyano.txt")
    >>> record = Cluster.read(handle)
    >>> handle.close()
    >>> genetree = record.treecluster(method='s')
    >>> genetree.scale()
    >>> exptree = record.treecluster(dist='u', transpose=1)
    >>> record.save("cyano_result", genetree, exptree)

这样会创建文件 ``cyano_result.cdt``, ``cyano_result.gtr``,
和 ``cyano_result.atr``.

类似地, 我们可以保存一个 *k*-均值的聚类方案:

.. code:: verbatim

    >>> from Bio import Cluster
    >>> handle = open("cyano.txt")
    >>> record = Cluster.read(handle)
    >>> handle.close()
    >>> (geneclusters, error, ifound) = record.kcluster(nclusters=5, npass=1000)
    >>> (expclusters, error, ifound) = record.kcluster(nclusters=2, npass=100, transpose=1)
    >>> record.save("cyano_result", geneclusters, expclusters)

这样会创建文件 ``cyano_result_K_G2_A2.cdt``,
``cyano_result_K_G2.kgg``, 和 ``cyano_result_K_A2.kag``.

15.9  辅助功能
-------------------------

``median(data)`` 返回一维向量 ``data`` 的中位数。

``mean(data)`` 返回一维向量 ``data`` 的均值。

``version()`` 返回内在 C 聚类库的版本号。
